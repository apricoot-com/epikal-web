generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// Representa una cuenta cliente del SaaS (tenant)
model Company {
  id                          String             @id @default(cuid())
  name                        String
  legalName                   String?
  slug                        String             @unique
  customDomain                String?            @unique
  status                      CompanyStatus      @default(ACTIVE)
  language                    String             @default("es")
  currency                    String             @default("USD")
  timezone                    String             @default("America/Mexico_City")
  socialUrls                  Json?
  subscriptionTier            SubscriptionTier   @default(FREE)
  subscriptionStatus          SubscriptionStatus @default(ACTIVE)
  subscriptionEndsAt          DateTime?
  customLimits                Json?
  gtmContainerId              String?
  fbPixelId                   String?
  fbAccessToken               String?
  createdAt                   DateTime           @default(now())
  updatedAt                   DateTime           @updatedAt
  siteTemplateId              String?
  siteSettings                Json?
  requiresBookingConfirmation Boolean            @default(false)
  description                 String?
  analyticsEvents             AnalyticsEvent[]
  bookings                    Booking[]
  siteTemplate                Template?          @relation("InstalledTemplate", fields: [siteTemplateId], references: [id])
  branding                    CompanyBranding?
  customers                   Customer[]
  dailyStats                  DailyStats[]
  locations                   Location[]
  reminderConfigs             ReminderConfig[]
  resources                   Resource[]
  services                    Service[]
  createdTemplates            Template[]         @relation("TemplateOwner")
  members                     UserCompany[]
  paymentMethods              PaymentMethod[]
  transactions                Transaction[]
  testimonials                Testimonial[]

  @@map("companies")
}

model Testimonial {
  id        String   @id @default(cuid())
  companyId String
  name      String
  title     String?
  text      String
  image     String?
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@map("testimonials")
}

/// Representa una persona que accede al SaaS
model User {
  id            String        @id @default(cuid())
  name          String
  email         String        @unique
  emailVerified Boolean       @default(false)
  image         String?
  status        UserStatus    @default(ACTIVE)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  accounts      Account[]
  resources     Resource[]
  sessions      Session[]
  memberships   UserCompany[]

  @@map("users")
}

/// Membresía Usuario-Empresa (many-to-many con rol)
model UserCompany {
  id        String           @id @default(cuid())
  userId    String
  companyId String
  role      Role             @default(STAFF)
  status    MembershipStatus @default(ACTIVE)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  company   Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, companyId])
  @@map("user_companies")
}

/// Identidad visual y verbal de la empresa
model CompanyBranding {
  id                String   @id @default(cuid())
  companyId         String   @unique
  logoUrl           String?
  primaryColor      String   @default("#3B82F6")
  secondaryColor    String   @default("#10B981")
  brandTone         String?
  brandKeywords     String[]
  brandRestrictions String[]
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  company           Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("company_brandings")
}

model PaymentMethod {
  id          String   @id @default(cuid())
  companyId   String
  gateway     String
  token       String
  last4       String?
  brand       String?
  expiryMonth Int?
  expiryYear  Int?
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@map("payment_methods")
}

/// Sedes / Ubicaciones físicas
model Location {
  id        String     @id @default(cuid())
  companyId String
  name      String
  address   String?
  city      String?
  country   String?
  phone     String?
  email     String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  company   Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  resources Resource[]

  @@map("locations")
}

/// Represents what the client buys
model Service {
  id              String            @id @default(cuid())
  companyId       String
  name            String
  slug            String
  description     String?
  duration        Int
  price           Decimal           @db.Decimal(10, 2)
  allowsDeposit   Boolean           @default(false)
  depositAmount   Decimal?          @db.Decimal(10, 2)
  status          ServiceStatus     @default(ACTIVE)
  isPublic        Boolean           @default(true)
  sortOrder       Int               @default(0)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  analyticsEvents AnalyticsEvent[]
  bookings        Booking[]
  resources       ServiceResource[]
  webPage         ServiceWebPage?
  company         Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, slug])
  @@map("services")
}

/// Represents who or what delivers the service
model Resource {
  id           String            @id @default(cuid())
  companyId    String
  locationId   String?
  type         ResourceType
  name         String
  description  String?
  bio          String?
  status       ServiceStatus     @default(ACTIVE)
  calendarId   String?
  image        String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  userId       String?
  availability Availability[]
  blockouts    Blockout[]
  bookings     Booking[]
  company      Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  location     Location?         @relation(fields: [locationId], references: [id])
  user         User?             @relation(fields: [userId], references: [id])
  services     ServiceResource[]

  @@unique([companyId, userId])
  @@map("resources")
}

/// Many-to-many relationship between Service and Resource
model ServiceResource {
  serviceId  String
  resourceId String
  createdAt  DateTime @default(now())
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  service    Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([serviceId, resourceId])
  @@map("service_resources")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verifications")
}

/// Defines a deployable site template (11ty build)
model Template {
  id            String    @id @default(cuid())
  name          String
  description   String?
  storagePath   String
  previewImage  String?
  isPublic      Boolean   @default(true)
  companyId     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  installations Company[] @relation("InstalledTemplate")
  company       Company?  @relation("TemplateOwner", fields: [companyId], references: [id])

  @@map("templates")
}

/// Web-specific configuration for a Service
model ServiceWebPage {
  id                String   @id @default(cuid())
  serviceId         String   @unique
  displayTitle      String?
  heroImage         String?
  content           String?
  blocks            Json?
  seo               Json?
  schedulingEnabled Boolean  @default(true)
  agentEnabled      Boolean  @default(false)
  analyticsEnabled  Boolean  @default(false)
  agentConfig       Json?
  bookingConfig     Json?
  faqs              Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  service           Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("service_web_pages")
}

/// Raw analytics events (page views, conversions, etc.)
model AnalyticsEvent {
  id          String   @id @default(cuid())
  companyId   String
  type        String
  path        String
  pageType    String
  serviceId   String?
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmContent  String?
  utmTerm     String?
  sessionId   String
  visitorId   String
  referrer    String?
  userAgent   String?
  timestamp   DateTime @default(now())
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  service     Service? @relation(fields: [serviceId], references: [id])

  @@index([companyId, timestamp])
  @@index([serviceId, timestamp])
  @@index([sessionId])
  @@map("analytics_events")
}

/// Aggregated daily statistics per company
model DailyStats {
  id             String   @id @default(cuid())
  companyId      String
  date           DateTime @db.Date
  pageViews      Int      @default(0)
  uniqueVisitors Int      @default(0)
  topServices    Json
  topSources     Json
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  company        Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, date])
  @@index([companyId, date])
  @@map("daily_stats")
}

/// Define el horario laboral estándar de un Recurso
model Availability {
  id          String    @id @default(cuid())
  resourceId  String
  dayOfWeek   DayOfWeek
  startTime   String
  endTime     String
  isAvailable Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  resource    Resource  @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@unique([resourceId, dayOfWeek, startTime])
  @@map("availabilities")
}

/// Excepciones al horario (Vacaciones, Almuerzo, etc)
model Blockout {
  id          String   @id @default(cuid())
  resourceId  String
  description String?
  startTime   DateTime
  endTime     DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  resource    Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@map("blockouts")
}

/// Cita agendada
model Booking {
  id                String               @id @default(cuid())
  companyId         String
  resourceId        String
  serviceId         String
  customerName      String
  customerEmail     String
  customerPhone     String?
  userId            String?
  customerId        String?
  startTime         DateTime
  endTime           DateTime
  status            BookingStatus        @default(CONFIRMED)
  notes             String?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  confirmationToken String?              @unique
  rescheduleToken   String?              @unique
  cancellationToken String?              @unique
  reminderLogs      BookingReminderLog[]
  company           Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer          Customer?            @relation(fields: [customerId], references: [id])
  resource          Resource             @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  service           Service              @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([resourceId, startTime])
  @@map("bookings")
}

model Customer {
  id            String    @id @default(cuid())
  companyId     String
  firstName     String
  lastName      String?
  email         String
  phone         String?
  userId        String?
  notes         String?
  tags          String[]
  totalBookings Int       @default(0)
  lastBookingAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  bookings      Booking[]
  company       Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, email])
  @@index([companyId])
  @@map("customers")
}

model ReminderConfig {
  id        String               @id @default(cuid())
  companyId String
  channel   ReminderChannel      @default(EMAIL)
  timeValue Int
  timeUnit  TimeUnit
  isActive  Boolean              @default(true)
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  logs      BookingReminderLog[]
  company   Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("reminder_configs")
}

model BookingReminderLog {
  id               String            @id @default(cuid())
  bookingId        String
  reminderConfigId String
  sentAt           DateTime          @default(now())
  channel          ReminderChannel
  status           ReminderLogStatus @default(SUCCESS)
  error            String?
  booking          Booking           @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  reminderConfig   ReminderConfig    @relation(fields: [reminderConfigId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@map("booking_reminder_logs")
}

enum Role {
  SUPERADMIN
  OWNER
  ADMIN
  STAFF
  VIEWER
}

enum CompanyStatus {
  ACTIVE
  SUSPENDED
}

enum UserStatus {
  ACTIVE
  BLOCKED
}

enum MembershipStatus {
  ACTIVE
  INVITED
  REVOKED
}

enum SubscriptionTier {
  FREE
  BASIC
  PROFESSIONAL
  TEAM
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum ResourceType {
  PROFESSIONAL
  PHYSICAL
}

enum ServiceStatus {
  ACTIVE
  INACTIVE
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum ReminderChannel {
  EMAIL
  WHATSAPP
  SMS
}

enum TimeUnit {
  MINUTES
  HOURS
  DAYS
}

enum ReminderLogStatus {
  SUCCESS
  FAILED
  PENDING
}

model Transaction {
  id              String            @id @default(cuid())
  companyId       String
  amount          Decimal           @db.Decimal(10, 2)
  currency        String            @default("USD")
  status          TransactionStatus
  type            TransactionType
  gatewayId       String?
  gatewayResponse Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  company         Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@map("transactions")
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum TransactionType {
  SUBSCRIPTION
  ONE_TIME
  REFUND
}
